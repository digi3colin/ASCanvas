package com.gamemeal.html {	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.CapsStyle;	import flash.display.GradientType;	import flash.display.Graphics;	import flash.display.JointStyle;	import flash.display.PixelSnapping;	import flash.display.Sprite;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;		import com.gamemeal.graphics.Bezier;	import com.gamemeal.utils.Utils;	/**
	 * @author Colin	 * know issue:	 * fill - flash use even odd fill, canvas using non-zero winding rule	 * autoClosePath - flash will close path if 2 point is too close.	 * antiAlias - it's slightly different from canvas.
	 */
	public class Canvas extends Sprite{		private var id:String;		private var w:int;		private var h:int;		private var _globalAlpha : Number=1;		private var _lineCap : String=CapsStyle.NONE;		private var _lineJoin : String=JointStyle.MITER;		private var _lineWidth : Number=1;		private var _blendMode : String;		private var _miterLimit : Number=10;		private var _shadowWidth : Number=NaN;		private var _shadowColor : Object=null;		private var _shadowOffsetX : Number=0;		private var _shadowOffsetY : Number=0;		private var _strokeStyle : Object="#000000";		private var _fillStyle : Object="#000000";				private var graphicState:Vector.<State>=new Vector.<State>();		private var context : Graphics;		private var clipSprite:Sprite;		private var clipContext:Graphics;				private var path:Array = [];		private var clipPath:Array=[];				private var canvasData:BitmapData;//		private var mode:String='firefox';				private var bufferSprite:Sprite;		private var localSpace : Sprite;		private var scaleSpace :Sprite;				private var canvasSpace:Sprite;				public function Canvas(id:String,width:int,height:int) {			this.id = id;			this.w = width;			this.h = height;			localSpace = new Sprite();			canvasSpace = new Sprite();			scaleSpace = new Sprite();			bufferSprite = new Sprite();			canvasSpace.addChild(localSpace);			scaleSpace.addChild(canvasSpace);			bufferSprite.addChild(scaleSpace);			clipSprite = new Sprite();			clipContext = clipSprite.graphics;			context = localSpace.graphics;			canvasData = new BitmapData(w,h,true,0x00000000);			this.addChild(new Bitmap(canvasData,PixelSnapping.ALWAYS));			this.addChild(bufferSprite);			bufferSprite.y = 200;		}		public function get fillStyle():*{			return _fillStyle;		}				public function set fillStyle(fillStyle:*):void{			//rgb(255,221,0), rgba(255,255,255,1), #FFFFFF			_fillStyle = fillStyle;		}				public function get globalAlpha():Number{			return _globalAlpha;		}		public function set globalAlpha(alpha:Number):void{			_globalAlpha = alpha;		}		public function get globalCompositeOperation():String{			return _blendMode;		}		public function set globalCompositeOperation(compositeOperation:String):void{			//TODO: change blendMode when set			_blendMode = compositeOperation;		}		public function get lineCap():String{			if(_lineCap == CapsStyle.ROUND)return 'round';			if(_lineCap == CapsStyle.SQUARE)return 'square';			return 'butt';		}				public function set lineCap(lineCap:String):void{			//butt|round|square			lineCap = lineCap.toLowerCase();			if(lineCap == 'square'){				_lineCap = CapsStyle.SQUARE;			}else if(lineCap == 'round'){				_lineCap = CapsStyle.ROUND;			}else{				_lineCap = CapsStyle.NONE;			}		}		public function get lineJoin():String{			if(_lineJoin == JointStyle.ROUND)return 'round';			if(_lineJoin == JointStyle.BEVEL)return 'bevel';			return 'miter';		}		public function set lineJoin(lineJoin:String):void{			//miter|bevel|round			lineJoin = lineJoin.toLowerCase();			if(lineJoin == 'round'){				_lineJoin = JointStyle.ROUND;			}else if(lineJoin == 'bevel'){				_lineJoin = JointStyle.BEVEL;			}else{				_lineJoin = JointStyle.MITER;			}		}		public function get lineWidth():Number{			return _lineWidth;		}		public function set lineWidth(lineWidth:Number):void{			_lineWidth = lineWidth;		}				public function get miterLimit():Number{			return _miterLimit;		}				public function set miterLimit(miterLimit:Number):void{			_miterLimit = miterLimit;		}				public function get shadowWidth():Number{			return _shadowWidth;		}		public function set shadowWidth(shadowWidth:Number):void{			_shadowWidth=shadowWidth;		}		public function get shadowBlur():Number{			return _shadowWidth;		}				public function set shadowBlur(shadowWidth:Number):void{			_shadowWidth = shadowWidth;		}				public function get shadowColor():*{			return _shadowColor;		}		public function set shadowColor(shadowColor:*):void{			_shadowColor = shadowColor;		}		public function get shadowOffsetX():Number{			return _shadowOffsetX;		}		public function set shadowOffsetX(shadowOffsetX:Number):void{			_shadowOffsetX = shadowOffsetX;		}				public function get shadowOffsetY():Number{			return _shadowOffsetY;		}		public function set shadowOffsetY(shadowOffsetY:Number):void{			_shadowOffsetY = shadowOffsetY;		}		public function set strokeStyle(strokeStyle:*):void{			_strokeStyle = strokeStyle;		}				public function get strokeStyle():*{			return _strokeStyle;		}/******************************************** * **************************************** * * **************************************** * * METHODS * **************************************** * * **************************************** * ****************************************** */		public function getContext(arg:String):Canvas{			arg;//this moment just 2d support;			return this;		}		/******************************************** * Canvas State Methods ********************************************/		public function restore():void{			var s:State = graphicState.pop();			localSpace.rotation = Utils.radianToDegree(Math.acos(s.localSpaceMatrix.a));			canvasSpace.x = s.canvasSpaceMatrix.tx;			canvasSpace.y = s.canvasSpaceMatrix.ty;			scaleSpace.scaleX = s.scaleSpaceMatrix.a;			scaleSpace.scaleY = s.scaleSpaceMatrix.d;						clipPath		= s.clipPath;			lineWidth		= s.lineWidth;			lineJoin		= s.lineJoin;			miterLimit		= s.miterLimit;			lineCap			= s.lineCap;			fillStyle		= s.fillStyle;			strokeStyle		= s.strokeStyle;			globalAlpha		= s.globalAlpha;			shadowColor		= s.shadowColor;			shadowOffsetX	= s.shadowOffsetX;			shadowOffsetY	= s.shadowOffsetY;			shadowWidth		= s.shadowWidth;		}				public function rotate(angle:Number):void{			localSpace.rotation+=Utils.radianToDegree(angle);		}		public function save():void{			var s:State = new State();			s.localSpaceMatrix= localSpace.transform.matrix;			s.canvasSpaceMatrix = canvasSpace.transform.matrix;			s.scaleSpaceMatrix = scaleSpace.transform.matrix;			s.clipPath		= clipPath;			s.lineWidth		= lineWidth;			s.lineJoin		= lineJoin;			s.miterLimit	= miterLimit;			s.lineCap		= lineCap;			s.fillStyle		= fillStyle;			s.strokeStyle	= strokeStyle;			s.globalAlpha	= globalAlpha;			s.shadowColor	= shadowColor;			s.shadowOffsetX	= shadowOffsetX;			s.shadowOffsetY	= shadowOffsetY;			s.shadowWidth	= shadowWidth;			graphicState.push(s);		}				public function scale(sx:Number, sy:Number):void{			scaleSpace.scaleX = sx;			scaleSpace.scaleY = sy;		}		public function translate(tx:Number, ty:Number):void{			var m:Matrix = localSpace.transform.matrix;			var tp:Point = m.transformPoint(new Point(tx,ty));			canvasSpace.x += tp.x;			canvasSpace.y += tp.y;		}/******************************************** * Working with paths ********************************************/		public function arc(x:Number, y:Number, radius:Number, startAngle:Number, endAngle:Number, clockwise:*):void{			if(path.length==0){				arguments[6] = NaN;				arguments[7] = NaN;				path.push({fnt:_moveTo,arg:[x,y],x:x,y:y});			}else{				arguments[6] = path[path.length-1].x;				arguments[7] = path[path.length-1].y;			}			var endX:Number = x+Math.cos(endAngle)*radius;			var endY:Number = y+Math.sin(endAngle)*radius;			canvasDrawTemplateMethod(_arc,arguments,endX,endY);						//unused parameter			startAngle;			clockwise;		}		public function arcTo(x1:Number, y1:Number, x2:Number, y2:Number, radius:Number):void{			if(path.length>0){				arguments[5]=path[path.length-1].x;				arguments[6]=path[path.length-1].y;			}			canvasDrawTemplateMethod(_arcTo,arguments,x2,y2);		}				public function bezierCurveTo(cp1x:Number, cp1y:Number, cp2x:Number, cp2y:Number, x:Number, y:Number):void{			if(path.length>0){				arguments[6]=path[path.length-1].x;				arguments[7]=path[path.length-1].y;			}			canvasDrawTemplateMethod(_bezierCurveTo,arguments,x,y);		}				public function beginPath():void{			path = new Array();		}				public function clip():void{			//TODO: verify how to use clip and implement			//copy the path to clipPath;			clipContext.beginFill(0,1);			executeDraw(clipContext,path);		}				public function closePath():void{			path.push({fnt:_closePath,arg:[]});		}				public function lineTo(x:Number, y:Number):void{			canvasDrawTemplateMethod(_lineTo,arguments,x,y);		}				public function moveTo(x:Number, y:Number):void{			canvasDrawTemplateMethod(_moveTo,arguments,x,y);		}				public function quadraticCurveTo(cpx:Number, cpy:Number, x:Number, y:Number):void{			canvasDrawTemplateMethod(_quadraticCurveTo,arguments,x,y);		}		public function rect(x:Number, y:Number, width:Number, height:Number):void{			canvasDrawTemplateMethod(_rect,arguments,x,y);		}		/******************************************** * Stroking a Path ********************************************/		public function stroke():void{			setLineStyle(context);			executeDraw(context, path);			flush();		}				public function strokeRect(x:Number, y:Number, width:Number, height:Number):void{			setLineStyle(context);			context.drawRect(x, y, width, height);			flush();		}		/******************************************** * Filling an Area ********************************************/		public function clearRect(x:Number, y:Number, width:Number, height:Number):void{			canvasData.fillRect(new Rectangle(x, y, width, height), 0x00000000);		}		public function fill():void{			setFillStyle(context);			executeDraw(context, path);			context.endFill();			flush();		}		public function fillRect(x:Number, y:Number, width:Number, height:Number):void{			setFillStyle(context);			context.drawRect(x, y, width, height);			context.endFill();			flush();		}		/******************************************** * Creating Gradient and Pattern Styles ********************************************/		public function createLinearGradient(x0:Number,y0:Number,x1:Number,y1:Number):LinearGradient{			return new LinearGradient(x0,y0,x1,y1);		}				public function createRadialGradient(x0:Number, y0:Number, r0:Number, x1:Number, y1:Number, r1:Number):RadialGradient{			return new RadialGradient(x0, y0, r0, x1, y1, r1);		}				public function createPattern(image:BitmapData,repetition:String):PatternFill{			return new PatternFill(image,repetition);		}/******************************************** * Drawing an Image ********************************************/		public function drawImage(image : BitmapData, sx:Number, sy:Number, swidth:Number=NaN, sheight:Number=NaN, dx:Number=NaN, dy:Number=NaN, dwidth:Number=NaN, dheight:Number=NaN):void{			if(isNaN(swidth)){};//first overload			if(isNaN(swidth)!=true){};//second overload			if(isNaN(dwidth)!=true){};//third overload			//TODO: draw an image		}		/******************************************** * private functions ********************************************/ 		private function canvasDrawTemplateMethod(fnt:Function,arg:Array,fixX:Number,fixY:Number):void{			if(path.length==0){				path.push({fnt:_moveTo,arg:[fixX,fixY],x:fixX,y:fixY});				return;			}			path.push({fnt:fnt,arg:arg,x:fixX,y:fixY});		}   		private function setLineStyle(context : Graphics,pixelHinting:Boolean=true) : void{			if(_strokeStyle is String){				var s1 : CSSColor = new CSSColor(String(_strokeStyle));				context.lineStyle(_lineWidth, s1.color, s1.alpha, pixelHinting,"normal", _lineCap, _lineJoin, _miterLimit);			}else			if(_strokeStyle is LinearGradient){				var s2 : * = LinearGradient(_strokeStyle);				context.lineGradientStyle(GradientType.LINEAR, s2.colors, s2.alphas, s2.ratios, s2.matrix, s2.spreadMethod, s2.interpolationMethod, s2.focalPointRatio);			}else			if(_strokeStyle is RadialGradient){				var s3 : * = RadialGradient(_strokeStyle);				context.lineGradientStyle(GradientType.RADIAL, s3.colors, s3.alphas, s3.ratios, s3.matrix, s3.spreadMethod, s3.interpolationMethod, s3.focalPointRatio);			} 		} 		private function setFillStyle(context : Graphics) : void{ 			context.lineStyle(undefined);			if(_fillStyle is String){				var s1 : CSSColor = new CSSColor(String(_fillStyle));				context.beginFill(s1.color, s1.alpha)			}else			if(_fillStyle is LinearGradient){				var s2:* = LinearGradient(_fillStyle);				context.beginGradientFill(GradientType.LINEAR, s2.colors, s2.alphas, s2.ratios, s2.matrix, s2.spreadMethod, s2.interpolationMethod, s2.focalPointRatio);			}else			if(_fillStyle is RadialGradient){				var s3 : * = RadialGradient(_fillStyle);				context.beginGradientFill(GradientType.RADIAL, s3.colors, s3.alphas, s3.ratios, s3.matrix, s3.spreadMethod, s3.interpolationMethod, s3.focalPointRatio);			} 		}		private function executeDraw(g:Graphics,arrayPath:Array):void{						//fill the path in clip			for(var i:int=0;i<arrayPath.length;i++){				arrayPath[i].fnt(arrayPath[i].arg,g);			}		}		private function _arc(arg:Array,graphics : Graphics) : void{			var d:Draw = new Draw(graphics);			setLineStyle(graphics,false);			d.arc(arg[0],arg[1],arg[2],Utils.radianToDegree(arg[3]),Utils.radianToDegree(arg[4]),arg[5],arg[6],arg[7]);			setLineStyle(graphics,true);		}		private function _arcTo(arg:Array,graphics : Graphics):void{			var x0:Number = arg[5];			var y0:Number = arg[6];			var x1:Number = arg[0];			var y1:Number = arg[1];			var x2:Number = arg[2];			var y2:Number = arg[3];			var radius:Number = arg[4];						var theta:Number = Math.atan2(y0-y1, x0-x1)-Math.atan2(y2-y1,x2-x1);			var lengthFromP1ToT1:Number = Math.abs(radius/Math.tan(theta/2));			var lengthFromP1ToC1:Number = Math.abs(radius/Math.sin(theta/2));			var xt0:Number = (x0-x1);			var yt0:Number = (y0-y1);			var l:Number = Math.sqrt((xt0*xt0)+(yt0*yt0));			xt0 = xt0*lengthFromP1ToT1/l+x1;			yt0 = yt0*lengthFromP1ToT1/l+y1;			var xt2:Number = (x2-x1);			var yt2:Number = (y2-y1);			l = Math.sqrt((xt2*xt2)+(yt2*yt2));			xt2 = xt2*lengthFromP1ToT1/l+x1;			yt2 = yt2*lengthFromP1ToT1/l+y1;			var cx:Number = (xt0+xt2)*0.5-x1;			var cy:Number = (yt0+yt2)*0.5-y1;			l = Math.sqrt((cx*cx)+(cy*cy));			cx = cx*lengthFromP1ToC1/l+x1;			cy = cy*lengthFromP1ToC1/l+y1;			var d:Draw = new Draw(graphics);			var startAngle:Number = Utils.radianToDegree(Math.atan2(yt0-cy, xt0-cx));			var endAngle:Number = Utils.radianToDegree(Math.atan2(yt2-cy, xt2-cx));			var dir:Boolean = (startAngle<endAngle);			if(x1>x2)dir = !dir;			graphics.moveTo(x0, y0);			graphics.lineTo(xt0, yt0);			d.arc(cx,cy,radius,startAngle,endAngle,dir);		}/*		private function mark(x:Number,y:Number,g : Graphics) : void{			g.moveTo(x-2, y-2);			g.lineTo(x+2, y+2);			g.moveTo(x+2, y-2);			g.lineTo(x-2, y+2);			g.moveTo(x,y);		}*/		private function _bezierCurveTo(arg:Array,graphics : Graphics):void{			var p0:Point = new Point(arg[6],arg[7]);			var p1:Point = new Point(arg[0],arg[1]);			var p2:Point = new Point(arg[2],arg[3]);			var p3:Point = new Point(arg[4],arg[5]);			graphics.lineTo(p0.x, p0.y); 			var bc : Bezier = new Bezier(graphics);			bc.drawCubicBezier(p0, p1, p2, p3, 4);		}		private function _closePath(arg:Array,graphics : Graphics):void{			var x:Number = path[0].x;			var y:Number = path[0].y;			graphics.lineTo(x,y);		}		private function _lineTo(arg:Array,graphics : Graphics):void{			var x:Number = arg[0];			var y:Number = arg[1];			graphics.lineTo(x, y);		}		private function _moveTo(arg:Array,graphics : Graphics):void{			var x:Number = arg[0];			var y:Number = arg[1];			graphics.moveTo(x, y);		}		private function _quadraticCurveTo(arg:Array,graphics : Graphics):void{			var cpx:Number = arg[0];			var cpy:Number = arg[1];			var x:Number = arg[2];			var y:Number = arg[3];			graphics.curveTo(cpx, cpy, x, y);		}		private function _rect(arg:Array,graphics : Graphics):void{			var x:Number=arg[0];			var y:Number=arg[1];			var width:Number=arg[2];			var height:Number=arg[3];			graphics.moveTo(x, y);			graphics.drawRect(x, y, width, height);		}				private function flush():void{			canvasData.draw(bufferSprite);			context.clear();		}	}}import flash.display.BitmapData;import flash.display.Graphics;import flash.geom.Matrix;class PatternFill {	internal static const REPEAT:String = "repeat";	internal static const REPEAT_X:String = "repeat-x";	internal static const REPEAT_Y:String = "repeat-y";	internal static const REPEAT_NO:String = "no-repeat";	public function PatternFill(image:BitmapData,repetition:String){			}}
class Draw{	private var g : Graphics;		public function Draw(g : Graphics) {		this.g = g;	}	public function arc(cx:Number, cy:Number, radius:Number, startAngle:Number, endAngle:Number, clockwise:*,lastX:Number=NaN,lastY:Number=NaN):void{//		if(startAngle<0)startAngle = 360+startAngle;		if(endAngle<0)endAngle = 360+endAngle;		var arc:Number;		if(clockwise==false||clockwise==0){			arc = endAngle - startAngle;		}else{			arc = 360-(endAngle - startAngle);			if(arc==0&&endAngle!=startAngle)arc=360;		}				if (Math.abs(arc)>360)arc = 360;		var segs:Number = Math.ceil(Math.abs(arc)/45);		var segAngle:Number = arc/segs;		var theta:Number,angle:Number;		if(clockwise==false||clockwise==0){			theta = (segAngle/180)*Math.PI;			angle = (startAngle/180)*Math.PI;		}else{			theta = -(segAngle/180)*Math.PI;			angle = (startAngle/180)*Math.PI;				}		var sx:Number = cx+Math.cos(angle)*radius;		var sy:Number = cy+Math.sin(angle)*radius;		if(isNaN(lastX)){			g.moveTo(sx,sy);		}else{			g.lineTo(sx,sy);		}		var angleMid:Number, bx:Number, by:Number, ctlx:Number, ctly:Number;		for (var i:int = 0; i<segs; i++) {			angle += theta;			angleMid = angle-(theta/2);			bx = cx+Math.cos(angle)*radius;			by = cy+Math.sin(angle)*radius;			ctlx = cx+Math.cos(angleMid)*(radius/Math.cos(theta/2));			ctly = cy+Math.sin(angleMid)*(radius/Math.cos(theta/2));			g.curveTo(ctlx, ctly, bx, by);		}				lastY;	}}class State{	public var localSpaceMatrix:Matrix;	public var canvasSpaceMatrix:Matrix;	public var scaleSpaceMatrix:Matrix;	public var clipPath:Array;	public var lineWidth : Number;	public var lineJoin : String;	public var miterLimit : Number;	public var lineCap : String;	public var _fillStyle : Object;	public var _strokeStyle : Object;	public var globalAlpha : Number;	public var shadowColor : Number;	public var shadowOffsetX:Number;	public var shadowOffsetY : Number;	public var shadowWidth : Number;		public function State(){	}		public function set fillStyle(style:Object):void{		//serialize, clone, deserialize		_fillStyle = style;	}		public function get fillStyle():Object{		return _fillStyle;	}	public function set strokeStyle(style:Object):void{		//serialize, clone, deserialize		_strokeStyle = style;	}	public function get strokeStyle():Object{		return _strokeStyle;	}}