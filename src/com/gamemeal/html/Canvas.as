package com.gamemeal.html {	import com.gamemeal.html.utils.CSSColor;	import com.gamemeal.html.utils.GraphicDrawCommands;	import com.gamemeal.html.utils.LinearGradient;	import com.gamemeal.html.utils.Path;	import com.gamemeal.html.utils.RadialGradient;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.CapsStyle;	import flash.display.GradientType;	import flash.display.Graphics;	import flash.display.JointStyle;	import flash.display.PixelSnapping;	import flash.display.Sprite;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;	/**
	 * @author Colin	 * know issue:	 * fill - flash use even odd fill, canvas using non-zero winding rule	 * autoClosePath - flash will close path if 2 point is too close.	 * antiAlias - it's slightly different from canvas.
	 */
	public class Canvas extends Sprite{		//private const TO_RAD:Number = Math.PI/180;		private const TO_DEG:Number = 180/Math.PI;				private var id:String;		private var w:int;		private var h:int;		private var _globalAlpha : Number=1;		private var _lineCap : String=CapsStyle.NONE;		private var _lineJoin : String=JointStyle.MITER;		private var _lineWidth : Number=1;		private var _blendMode : String;		private var _miterLimit : Number=10;		private var _shadowWidth : Number=NaN;		private var _shadowColor : Object=null;		private var _shadowOffsetX : Number=0;		private var _shadowOffsetY : Number=0;		private var _strokeStyle : Object="#000000";		private var _fillStyle : Object="#000000";				private var graphicState:Vector.<State>=new Vector.<State>();		private var context : Graphics;		private var clipSprite:Sprite;		private var clipContext:Graphics;				private var path:Vector.<Path>;		private var clipPath:Vector.<Path>;				private var canvasData:BitmapData;//		private var mode:String='firefox';				private var bufferSprite:Sprite;		private var localSpace : Sprite;		private var scaleSpace :Sprite;				private var canvasSpace:Sprite;				private var drawCommands:GraphicDrawCommands;				public function Canvas(id:String,width:int,height:int) {			this.id = id;			this.w = width;			this.h = height;			localSpace = new Sprite();			canvasSpace = new Sprite();			scaleSpace = new Sprite();			bufferSprite = new Sprite();			canvasSpace.addChild(localSpace);			scaleSpace.addChild(canvasSpace);			bufferSprite.addChild(scaleSpace);			clipSprite = new Sprite();			clipContext = clipSprite.graphics;			context = localSpace.graphics;			canvasData = new BitmapData(w,h,true,0x00000000);			this.addChild(new Bitmap(canvasData,PixelSnapping.ALWAYS));			this.addChild(bufferSprite);			bufferSprite.y = 200;		}		public function get fillStyle():*{			return _fillStyle;		}				public function set fillStyle(fillStyle:*):void{			//rgb(255,221,0), rgba(255,255,255,1), #FFFFFF			_fillStyle = fillStyle;		}				public function get globalAlpha():Number{			return _globalAlpha;		}		public function set globalAlpha(alpha:Number):void{			_globalAlpha = alpha;		}		public function get globalCompositeOperation():String{			return _blendMode;		}		public function set globalCompositeOperation(compositeOperation:String):void{			//TODO: change blendMode when set			_blendMode = compositeOperation;		}		public function get lineCap():String{			if(_lineCap == CapsStyle.ROUND)return 'round';			if(_lineCap == CapsStyle.SQUARE)return 'square';			return 'butt';		}				public function set lineCap(lineCap:String):void{			//butt|round|square			lineCap = lineCap.toLowerCase();			if(lineCap == 'square'){				_lineCap = CapsStyle.SQUARE;			}else if(lineCap == 'round'){				_lineCap = CapsStyle.ROUND;			}else{				_lineCap = CapsStyle.NONE;			}		}		public function get lineJoin():String{			if(_lineJoin == JointStyle.ROUND)return 'round';			if(_lineJoin == JointStyle.BEVEL)return 'bevel';			return 'miter';		}		public function set lineJoin(lineJoin:String):void{			//miter|bevel|round			lineJoin = lineJoin.toLowerCase();			if(lineJoin == 'round'){				_lineJoin = JointStyle.ROUND;			}else if(lineJoin == 'bevel'){				_lineJoin = JointStyle.BEVEL;			}else{				_lineJoin = JointStyle.MITER;			}		}		public function get lineWidth():Number{			return _lineWidth;		}		public function set lineWidth(lineWidth:Number):void{			_lineWidth = lineWidth;		}				public function get miterLimit():Number{			return _miterLimit;		}				public function set miterLimit(miterLimit:Number):void{			_miterLimit = miterLimit;		}				public function get shadowWidth():Number{			return _shadowWidth;		}		public function set shadowWidth(shadowWidth:Number):void{			_shadowWidth=shadowWidth;		}		public function get shadowBlur():Number{			return _shadowWidth;		}				public function set shadowBlur(shadowWidth:Number):void{			_shadowWidth = shadowWidth;		}				public function get shadowColor():*{			return _shadowColor;		}		public function set shadowColor(shadowColor:*):void{			_shadowColor = shadowColor;		}		public function get shadowOffsetX():Number{			return _shadowOffsetX;		}		public function set shadowOffsetX(shadowOffsetX:Number):void{			_shadowOffsetX = shadowOffsetX;		}				public function get shadowOffsetY():Number{			return _shadowOffsetY;		}		public function set shadowOffsetY(shadowOffsetY:Number):void{			_shadowOffsetY = shadowOffsetY;		}		public function set strokeStyle(strokeStyle:*):void{			_strokeStyle = strokeStyle;		}				public function get strokeStyle():*{			return _strokeStyle;		}/******************************************** * **************************************** * * **************************************** * * METHODS * **************************************** * * **************************************** * ****************************************** */		public function getContext(arg:String):Canvas{			arg;//this moment just 2d support;			return this;		}		/******************************************** * Canvas State Methods ********************************************/		public function restore():void{			var s:State = graphicState.pop();			localSpace.rotation = TO_DEG*Math.acos(s.localSpaceMatrix.a);			canvasSpace.x = s.canvasSpaceMatrix.tx;			canvasSpace.y = s.canvasSpaceMatrix.ty;			scaleSpace.scaleX = s.scaleSpaceMatrix.a;			scaleSpace.scaleY = s.scaleSpaceMatrix.d;						clipPath		= s.clipPath;			lineWidth		= s.lineWidth;			lineJoin		= s.lineJoin;			miterLimit		= s.miterLimit;			lineCap			= s.lineCap;			fillStyle		= s.fillStyle;			strokeStyle		= s.strokeStyle;			globalAlpha		= s.globalAlpha;			shadowColor		= s.shadowColor;			shadowOffsetX	= s.shadowOffsetX;			shadowOffsetY	= s.shadowOffsetY;			shadowWidth		= s.shadowWidth;		}				public function rotate(angle:Number):void{			localSpace.rotation+=TO_DEG*(angle);		}		public function save():void{			var s:State = new State();			s.localSpaceMatrix= localSpace.transform.matrix;			s.canvasSpaceMatrix = canvasSpace.transform.matrix;			s.scaleSpaceMatrix = scaleSpace.transform.matrix;			s.clipPath		= clipPath;			s.lineWidth		= lineWidth;			s.lineJoin		= lineJoin;			s.miterLimit	= miterLimit;			s.lineCap		= lineCap;			s.fillStyle		= fillStyle;			s.strokeStyle	= strokeStyle;			s.globalAlpha	= globalAlpha;			s.shadowColor	= shadowColor;			s.shadowOffsetX	= shadowOffsetX;			s.shadowOffsetY	= shadowOffsetY;			s.shadowWidth	= shadowWidth;			graphicState.push(s);		}				public function scale(sx:Number, sy:Number):void{			scaleSpace.scaleX = sx;			scaleSpace.scaleY = sy;		}		public function translate(tx:Number, ty:Number):void{			var m:Matrix = localSpace.transform.matrix;			var tp:Point = m.transformPoint(new Point(tx,ty));			canvasSpace.x += tp.x;			canvasSpace.y += tp.y;		}/******************************************** * Working with paths ********************************************/		public function arc(x:Number, y:Number, radius:Number, startAngle:Number, endAngle:Number, clockwise:*):void{			if(path.length==0){				arguments[6] = NaN;				arguments[7] = NaN;				path.push(new Path(drawCommands._moveTo,[x,y],x,y));//{fnt:drawCommands._moveTo,arg:[x,y],x:x,y:y});			}else{				arguments[6] = path[path.length-1].x;				arguments[7] = path[path.length-1].y;			}			var endX:Number = x+Math.cos(endAngle)*radius;			var endY:Number = y+Math.sin(endAngle)*radius;						canvasDrawTemplateMethod(drawCommands._arc,arguments,endX,endY);						//unused parameter			startAngle;			clockwise;		}		public function arcTo(x1:Number, y1:Number, x2:Number, y2:Number, radius:Number):void{			if(path.length>0){				arguments[5]=path[path.length-1].x;				arguments[6]=path[path.length-1].y;			}			canvasDrawTemplateMethod(drawCommands._arcTo,arguments,x2,y2);			x1;y1;radius;		}				public function bezierCurveTo(cp1x:Number, cp1y:Number, cp2x:Number, cp2y:Number, x:Number, y:Number):void{			if(path.length>0){				arguments[6]=path[path.length-1].x;				arguments[7]=path[path.length-1].y;			}			canvasDrawTemplateMethod(drawCommands._bezierCurveTo,arguments,x,y);			cp1x;cp1y;cp2x;cp2y;		}				public function beginPath():void{			path = new Vector.<Path>();			drawCommands = new GraphicDrawCommands(path,setLineStyle);		}				public function clip():void{			//TODO: verify how to use clip and implement			//copy the path to clipPath;			clipContext.beginFill(0,1);			executeDraw(clipContext,path);		}				public function closePath():void{			path.push(new Path(drawCommands._closePath,[],0,0));		}				public function lineTo(x:Number, y:Number):void{			canvasDrawTemplateMethod(drawCommands._lineTo,arguments,x,y);		}				public function moveTo(x:Number, y:Number):void{			canvasDrawTemplateMethod(drawCommands._moveTo,arguments,x,y);		}				public function quadraticCurveTo(cpx:Number, cpy:Number, x:Number, y:Number):void{			canvasDrawTemplateMethod(drawCommands._quadraticCurveTo,arguments,x,y);			cpx;cpy;		}		public function rect(x:Number, y:Number, width:Number, height:Number):void{			canvasDrawTemplateMethod(drawCommands._rect,arguments,x,y);			width;height;		}		/******************************************** * Stroking a Path ********************************************/		public function stroke():void{			setLineStyle(context);			executeDraw(context, path);			flush();		}				public function strokeRect(x:Number, y:Number, width:Number, height:Number):void{			setLineStyle(context);			context.drawRect(x, y, width, height);			flush();		}		/******************************************** * Filling an Area ********************************************/		public function clearRect(x:Number, y:Number, width:Number, height:Number):void{			canvasData.fillRect(new Rectangle(x, y, width, height), 0x00000000);		}		public function fill():void{			setFillStyle(context);			executeDraw(context, path);			context.endFill();			flush();		}		public function fillRect(x:Number, y:Number, width:Number, height:Number):void{			setFillStyle(context);			context.drawRect(x, y, width, height);			context.endFill();			flush();		}		/******************************************** * Creating Gradient and Pattern Styles ********************************************/		public function createLinearGradient(x0:Number,y0:Number,x1:Number,y1:Number):LinearGradient{			return new LinearGradient(x0,y0,x1,y1);		}				public function createRadialGradient(x0:Number, y0:Number, r0:Number, x1:Number, y1:Number, r1:Number):RadialGradient{			return new RadialGradient(x0, y0, r0, x1, y1, r1);		}				public function createPattern(image:BitmapData,repetition:String):PatternFill{			return new PatternFill(image,repetition);		}/******************************************** * Drawing an Image ********************************************/		public function drawImage(image : BitmapData, sx:Number, sy:Number, swidth:Number=NaN, sheight:Number=NaN, dx:Number=NaN, dy:Number=NaN, dwidth:Number=NaN, dheight:Number=NaN):void{			if(isNaN(swidth)){};//first overload			if(isNaN(swidth)!=true){};//second overload			if(isNaN(dwidth)!=true){};//third overload			//TODO: draw an image			image;sx;sy;sheight;dx;dy;dheight;		}/******************************************** * private functions ********************************************/ 		private function canvasDrawTemplateMethod(fnt:Function,arg:Array,fixX:Number,fixY:Number):void{			if(path.length==0){				path.push(new Path(drawCommands._moveTo,[fixX,fixY],fixX,fixY));				return;			}			path.push(new Path(fnt,arg,fixX,fixY));//{fnt:fnt,arg:arg,x:fixX,y:fixY});		}   		private function setLineStyle(context : Graphics,pixelHinting:Boolean=true) : void{			if(_strokeStyle is String){				var s1 : CSSColor = new CSSColor(String(_strokeStyle));				context.lineStyle(_lineWidth, s1.color, s1.alpha, pixelHinting,"normal", _lineCap, _lineJoin, _miterLimit);			}else			if(_strokeStyle is LinearGradient){				var s2 : LinearGradient = LinearGradient(_strokeStyle);				context.lineGradientStyle(GradientType.LINEAR, s2.colors, s2.alphas, s2.ratios, s2.matrix, s2.spreadMethod, s2.interpolationMethod, s2.focalPointRatio);			}else			if(_strokeStyle is RadialGradient){				var s3 : RadialGradient = RadialGradient(_strokeStyle);				context.lineGradientStyle(GradientType.RADIAL, s3.colors, s3.alphas, s3.ratios, s3.matrix, s3.spreadMethod, s3.interpolationMethod, s3.focalPointRatio);			} 		} 		private function setFillStyle(context : Graphics) : void{ 			context.lineStyle(undefined);			if(_fillStyle is String){				var s1 : CSSColor = new CSSColor(String(_fillStyle));				context.beginFill(s1.color, s1.alpha);			}else			if(_fillStyle is LinearGradient){				var s2:LinearGradient = LinearGradient(_fillStyle);				context.beginGradientFill(GradientType.LINEAR, s2.colors, s2.alphas, s2.ratios, s2.matrix, s2.spreadMethod, s2.interpolationMethod, s2.focalPointRatio);			}else			if(_fillStyle is RadialGradient){				var s3 :RadialGradient = RadialGradient(_fillStyle);				context.beginGradientFill(GradientType.RADIAL, s3.colors, s3.alphas, s3.ratios, s3.matrix, s3.spreadMethod, s3.interpolationMethod, s3.focalPointRatio);			} 		}				private function flush():void{			canvasData.draw(bufferSprite);			context.clear();		}				private function executeDraw(g:Graphics,arrayPath:Vector.<Path>):void{						//fill the path in clip			for(var i:int=0;i<arrayPath.length;i++){				arrayPath[i].fnt(arrayPath[i].arg,g);			}		}	}}import com.gamemeal.html.utils.Path;import flash.display.BitmapData;import flash.geom.Matrix;class PatternFill {	internal static const REPEAT:String = "repeat";	internal static const REPEAT_X:String = "repeat-x";	internal static const REPEAT_Y:String = "repeat-y";	internal static const REPEAT_NO:String = "no-repeat";	public function PatternFill(image:BitmapData,repetition:String){			}}class State{	public var localSpaceMatrix:Matrix;	public var canvasSpaceMatrix:Matrix;	public var scaleSpaceMatrix:Matrix;	public var clipPath:Vector.<Path>;	public var lineWidth : Number;	public var lineJoin : String;	public var miterLimit : Number;	public var lineCap : String;	public var _fillStyle : Object;	public var _strokeStyle : Object;	public var globalAlpha : Number;	public var shadowColor : Number;	public var shadowOffsetX:Number;	public var shadowOffsetY : Number;	public var shadowWidth : Number;		public function State(){	}		public function set fillStyle(style:Object):void{		//serialize, clone, deserialize		_fillStyle = style;	}		public function get fillStyle():Object{		return _fillStyle;	}	public function set strokeStyle(style:Object):void{		//serialize, clone, deserialize		_strokeStyle = style;	}	public function get strokeStyle():Object{		return _strokeStyle;	}}
